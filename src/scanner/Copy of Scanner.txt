package scanner;

import java.io.File;
import java.io.FileInputStream;
import java.io.BufferedInputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.*;

import java.util.Vector;

/** A scanner is able to separate tokens from an input stream, following states
 * defined in a finale state automata. */
public class Scanner
{
    private Reader charStream = null;
    private FinaleStateAutomata FSA = null;
    private Vector m_listeners = null;
    private CharStreamPosition m_previousPosition = null;
    private CharStreamPosition m_position = null;
    private StringBuffer m_currentLine = null;

    /** Creates a new scanner to scan the specified string.
     * @param charStreamValue A string to be scanned. */
    public Scanner(String charStreamValue)
    {  this(new StringReader(charStreamValue)); }

    public Scanner(Reader readerStream)
    {
       //charStream = readerStream;
       m_listeners = new Vector();
       init(readerStream);
    }

    /** Creates a new scanner. */
    public Scanner()
    { m_listeners = new Vector(); }

	/** Inits this scanner to be able to perform a scan on the given string
	 * @param charStreamValue A string to be scanned. */
    public void init(String charStreamValue)
    { init(new StringReader(charStreamValue)); }

    public void init(Reader readerStream)
    {
      charStream = readerStream;
      FSA =  null;
      m_currentLine = new StringBuffer();
      m_previousPosition = new CharStreamPosition();
      //the position is before the first character
      //column=0, line =1, offset=-1
      m_position = new CharStreamPosition(0,1,-1);
    }

	/** Adds a listener to this scanner.
	 * @param listener The listener to be added to this scanner. */
    public void addListener(ScannerListenerInterface listener)
    { m_listeners.addElement(listener); }

	/** Removes a listener from this scanner.
	 * @param listener The listener to be removed from this scanner. */
    public void removeListener(ScannerListenerInterface listener)
    { m_listeners.removeElement(listener); }

    /** Returns the next token encountered.
     * @return The next token encountered.
     * @exception Thrown if there's no next valid token. */
    /*public Token oldNextToken() throws NoSuchTokenException
    {
      String token = null;
      boolean tokenFound = false;
      boolean lastCharacterWasEndOfLine = false;
      boolean endOfStreamReached = false;
      char[] currentChar = new char[1];
      while (!tokenFound && !endOfStreamReached)
      {
        try
        {
          if (lastCharacterWasEndOfLine)
          {
            lastCharacterWasEndOfLine=false;
            //m_previousPosition.setPosition(m_position);
            m_position.setColumn(1);
            m_position.setLine(m_position.getLine()+1);
          }
          //System.out.println("CHAR N°" + charIndex + " : " + charStream.charAt(charIndex) );
          charStream.mark(1);
          if (charStream.read(currentChar)==-1)
            endOfStreamReached = true;
          else
          {
            m_previousPosition.setPosition(m_position);
            m_position.setColumn(m_position.getColumn()+1);
            m_position.setCharactersOffset(m_position.getCharactersOffset()+1);
            if (currentChar[0]=='\n')
            {
              lastCharacterWasEndOfLine = true;
              //m_currentLine.append("\n");
              //if (m_currentLine.charAt(0)=='\n')
              //  m_currentLine.deleteCharAt(0);
              //System.out.println("Scanner - processed line : " + new String(m_currentLine));
            }
            FSA.sendChar(currentChar[0]);
            m_currentLine.append(currentChar);
            if (currentChar[0]=='\n')
            {
              notifyListenersForLineScanned(new String(m_currentLine));
              m_currentLine = new StringBuffer();
            }
          }
        }
        catch (NoTransitionFoundException e)
        {
          if (FSA.getCurrentState().isTokenState())
          {
            //==================a valid token has been found.
            try
            {
              charStream.reset();
              m_position.setPosition(m_previousPosition);
              m_previousPosition.setPosition(1,0,0);
              //m_previousPosition.copyFrom(m_position);
              //m_position.setColumn(m_position.getColumn()-1);
              //m_position.setCharactersOffset(m_position.getCharactersOffset()-1);
            }
            catch (IOException ex)
            {ex.printStackTrace();}
            token = FSA.getReceivedCharacters();
            tokenFound = true;
            //if (currentChar[0]!='\n')
              //m_currentLine.append(token);
          }
          else
          {
            //=================an invalid character has been found.
            m_currentLine.append(currentChar);
            notifyListenersForInvalidCharacter(currentChar[0], (CharStreamPosition)getPosition().clone());
            FSA.initialize();
            //===== line changed in case on invalid character
            if (currentChar[0]=='\n')
            {
              notifyListenersForLineScanned(new String(m_currentLine));
              m_currentLine = new StringBuffer();
            }
            //===== end of line changed in case on invalid character

          }
        }
        catch (java.io.IOException e)
        { e.printStackTrace(); }
      }
      if (endOfStreamReached)
      {
        if (FSA.getCurrentState().isTokenState())
          token = FSA.getReceivedCharacters();
        else
        {
          FSA.initialize();
          throw new NoSuchTokenException();
        }
      }
      TokenType currentState = FSA.getCurrentState().getType();
      FSA.initialize();
      Token tok = new Token(token,
                            currentState,
                            new CharStreamPosition(m_position.getColumn()-(token.length()-1)
                                                   , m_position.getLine()
                                                   , m_position.getCharactersOffset()-(token.length()-1)));
                            //new CharStreamPosition(m_position));

      notifyListenersForToken(tok);
      return tok;
    }*/

    public Token nextToken() throws NoSuchTokenException
    {
      String token = null;
      boolean tokenFound = false;
      boolean lastAcceptedCharacterWasEndOfLine = false;
      boolean endOfStreamReached = false;
      char[] currentChar = new char[1];
      while (!tokenFound && !endOfStreamReached)
      {
        try
        {
          if (lastAcceptedCharacterWasEndOfLine)
          {
            lastAcceptedCharacterWasEndOfLine=false;
            m_position.setColumn(1);
            m_position.setLine(m_position.getLine()+1);
          }
          //System.out.println("CHAR N°" + charIndex + " : " + charStream.charAt(charIndex) );
          charStream.mark(1);
          if (charStream.read(currentChar)==-1)
            endOfStreamReached = true;
          else
          {
            m_previousPosition.setPosition(m_position);
            m_position.setColumn(m_position.getColumn()+1);
            m_position.setCharactersOffset(m_position.getCharactersOffset()+1);
            if (currentChar[0]=='\n')
              lastAcceptedCharacterWasEndOfLine = true;
            if (FSA.getTransitionFor(currentChar[0])!=null)
            {
              FSA.sendChar(currentChar[0]);
              m_currentLine.append(currentChar);
              if (currentChar[0]=='\n')
              {
                notifyListenersForLineScanned(new String(m_currentLine));
                m_currentLine = new StringBuffer();
              }
            }
            else
            {
              if (FSA.getCurrentState().isTokenState())
              {
                //if the last character was an end of line, it will be reinjected
                //for next token => we consider we are still at the same line
                lastAcceptedCharacterWasEndOfLine=false;
                //==================a valid token has been found.
                try
                {
                  charStream.reset();
                  m_position.setPosition(m_previousPosition);
                  m_previousPosition.setPosition(1,1,0);
                }
                catch (IOException ex)
                {ex.printStackTrace();}
                token = FSA.getReceivedCharacters();
                tokenFound = true;
              }
              else
              {
                //=================an invalid character has been found.
                m_currentLine.append(currentChar);
                notifyListenersForInvalidCharacter(currentChar[0], (CharStreamPosition)getPosition().clone());
                FSA.initialize();
                //===== line changed in case on invalid character
                if (currentChar[0]=='\n')
                {
                  notifyListenersForLineScanned(new String(m_currentLine));
                  m_currentLine = new StringBuffer();
                }
                //===== end of line changed in case on invalid character

              }
            }
          }
        //}
        //catch (NoTransitionFoundException e)
        //{
        }
        catch (java.io.IOException e)
        { e.printStackTrace(); }
      }
      if (endOfStreamReached)
      {
        if (FSA.getCurrentState().isTokenState())
          token = FSA.getReceivedCharacters();
        else
        {
          FSA.initialize();
          throw new NoSuchTokenException();
        }
      }
      TokenType currentState = FSA.getCurrentState().getType();
      FSA.initialize();
      Token tok = new Token(token,
                            currentState,
                            new CharStreamPosition(m_position.getColumn()-(token.length()-1)
                                                   , m_position.getLine()
                                                   , m_position.getCharactersOffset()-(token.length()-1)));
      //new CharStreamPosition(m_position));

      notifyListenersForToken(tok);
      return tok;
    }

    /** Returns <TT>true</TT> if there's any character left.
     * @return <TT>true</TT> if there's any character left, <TT>false</TT>
     * otherwise. */
    public boolean hasNext()
    {
      int hasNext = -1;
      try
      {
        charStream.mark(0);
        hasNext = charStream.read(new char[1]);
        charStream.reset();
      }
      catch (IOException e)
      { e.printStackTrace(); }
      return (hasNext!=-1);
    }

    /** Returns the current finale state automata currently used to separate
     * tokens.
     * @return the current finale state automata currently used to separate
     * tokens. */
    public FinaleStateAutomata getFinaleStateAutomata()
    { return FSA; }

    public void setFinaleStateAutomata(FinaleStateAutomata fsa)
    { FSA = fsa; }

    /** Returns the position of the scanner if the input stream.
     * @return The position of the scanner if the input stream. The last processed
     * character position. */
    public CharStreamPosition getPosition()
    { return m_position; }

    public String getCurrentLine()
    { return new String(m_currentLine); }

    protected void notifyListenersForToken(Token token)
    {
      TokenEvent evt = new TokenEvent(this, token);
      for (int i=0; i<m_listeners.size();i++)
        ((ScannerListenerInterface)m_listeners.elementAt(i)).tokenGenerated(evt);
    }

    protected void notifyListenersForInvalidCharacter(char character, CharStreamPosition pos)
    {
      InvalidCharacterEvent evt = new InvalidCharacterEvent(this, character, pos);
      for (int i=0; i<m_listeners.size();i++)
        ((ScannerListenerInterface)m_listeners.elementAt(i)).invalidCharacter(evt);
    }

    protected void notifyListenersForLineScanned(String line)
    {
      for (int i=0; i<m_listeners.size();i++)
        ((ScannerListenerInterface)m_listeners.elementAt(i)).lineProcessed(line);
    }
}
