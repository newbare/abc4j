package abc.parser.def;

import java.util.Vector;
import scanner.FinaleStateAutomata;
import scanner.AutomataDefinition;
import abc.parser.AbcTokenType;
import scanner.TokenType;

public class DefinitionFactory
{

  public static Vector m_allPreviouslyCreatedDefinitions = new Vector();

  /*public static FinaleStateAutomata getAutomata(TokenType abcTokenType)
  { return new FinaleStateAutomata(getDefinition(abcTokenType)); }

  public static FinaleStateAutomata getAutomata(TokenType[] tokenTypes)
  { return new FinaleStateAutomata(getDefinition(tokenTypes)); }*/

  public static DefinitionCache getDefinition(TokenType abcTokenType)
  {
    TokenType[] tokenTypes = {abcTokenType};
    //System.out.println("getAutomataFor(" + toString(tokenTypes));
    DefinitionCache cacheDef = null;
    cacheDef = getCacheDefinition(tokenTypes);

    if (cacheDef==null)
    {
      AutomataDefinition automataDef = null;
    if (abcTokenType==(AbcTokenType.FIELD_NUMBER)) automataDef = new FieldNumberDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_TITLE)) automataDef = new FieldTitleDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_AREA)) automataDef = new FieldAreaDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_BOOK)) automataDef = new FieldBookDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_COMPOSER)) automataDef = new FieldComposerDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_DISCOGRAPHY)) automataDef = new FieldDiscographyDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_ELEMSKIP)) automataDef = new FieldElemskipDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_GROUP)) automataDef = new FieldGroupDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_HISTORY)) automataDef = new FieldHistoryDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_INFORMATION)) automataDef = new FieldInformationDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_DEFAULT_LENGTH)) automataDef = new FieldDefaultLengthDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_METER)) automataDef = new FieldMeterDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_NOTES)) automataDef = new FieldNotesDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_ORIGIN)) automataDef = new FieldOriginDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_PARTS)) automataDef = new FieldPartsDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_RHYTHM)) automataDef = new FieldRhythmDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_SOURCE)) automataDef = new FieldSourceDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_TEMPO)) automataDef = new FieldTempoDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_TRANSCRNOTES)) automataDef = new FieldTranscriptionNotesDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_KEY)) automataDef = new FieldKeyDefinition();
    else if (abcTokenType==(AbcTokenType.FIELD_WORDS)) automataDef = new FieldWordsDefinition();
    else if (abcTokenType==(AbcTokenType.KEY_HP)) automataDef = new KeyHPDefinition();
    else if (abcTokenType==(AbcTokenType.C_METER)) automataDef = new MeterCDefinition();
    else if (abcTokenType==(AbcTokenType.TEXT)) automataDef = new TextDefinition();
    else if (abcTokenType==(AbcTokenType.NUMBER)) automataDef = new NumberDefinition();
    else if (abcTokenType==(AbcTokenType.DIGIT)) automataDef = new DigitDefinition();
    else if (abcTokenType==(AbcTokenType.FRACTION)) automataDef = new FractionDefinition();
    else if (abcTokenType==(AbcTokenType.PART)) automataDef = new PartDefinition();
    else if (abcTokenType==(AbcTokenType.PARENTHESIS_OPEN)) automataDef = new ParenthesisOpenDefinition();
    else if (abcTokenType==(AbcTokenType.PARENTHESIS_CLOSE)) automataDef = new ParenthesisCloseDefinition();
    else if (abcTokenType==(AbcTokenType.FRACTION)) automataDef = new FractionDefinition();
    else if (abcTokenType==(AbcTokenType.SPACE)) automataDef = new SpaceDefinition();
    else if (abcTokenType==(AbcTokenType.LINE_FEED)) automataDef = new LineFeedDefinition();
    else if (abcTokenType==(AbcTokenType.LINE_BREAK)) automataDef = new LineBreakDefinition();
    else if (abcTokenType==(AbcTokenType.NO_LINE_BREAK)) automataDef = new NoLineBreakDefinition();
    else if (abcTokenType==(AbcTokenType.BASE_NOTE)) automataDef = new BaseNoteDefinition();
    else if (abcTokenType==(AbcTokenType.KEY_ACCIDENTAL)) automataDef = new KeyAccidentalDefinition();
    else if (abcTokenType==(AbcTokenType.ACCIDENTAL)) automataDef = new AccidentalDefinition();
    else if (abcTokenType==(AbcTokenType.MODE))automataDef = new ModeDefinition();
    else if (abcTokenType==(AbcTokenType.COMMENT)) automataDef = new CommentDefinition();
    else if (abcTokenType==(AbcTokenType.GUITAR_CHORD)) automataDef = new GuitarChordDefinition();
    else if (abcTokenType==(AbcTokenType.GRACING_BEGIN)) automataDef = new GracingBeginDefinition();
    else if (abcTokenType==(AbcTokenType.GRACING_END)) automataDef = new GracingEndDefinition();
    else if (abcTokenType==(AbcTokenType.GRACING)) automataDef = new GracingDefinition();
    else if (abcTokenType==(AbcTokenType.REST)) automataDef = new RestDefinition();
    else if (abcTokenType==(AbcTokenType.BARLINE)) automataDef = new BarlineDefinition();
    else if (abcTokenType==(AbcTokenType.NTH_REPEAT)) automataDef = new NthRepeatDefinition();
    else if (abcTokenType==(AbcTokenType.BEGIN_SLUR)) automataDef = new SlurBeginDefinition();
    else if (abcTokenType==(AbcTokenType.END_SLUR)) automataDef = new SlurEndDefinition();
    else if (abcTokenType==(AbcTokenType.USER_DEFINED)) automataDef = new UserDefinedDefinition();
    else if (abcTokenType==(AbcTokenType.OCTAVE)) automataDef = new OctaveDefinition();
    else if (abcTokenType==(AbcTokenType.BROKEN_RHYTHM)) automataDef = new BrokenRhythmDefinition();
    else if (abcTokenType==(AbcTokenType.TIE)) automataDef = new TieDefinition();
    else if (abcTokenType==(AbcTokenType.TUPLET_SPEC)) automataDef = new TupletSpecDefinition();
    else if (abcTokenType==(AbcTokenType.MULTI_NOTE_BEGIN)) automataDef = new MultiNoteBeginDefinition();
    else if (abcTokenType==(AbcTokenType.MULTI_NOTE_END)) automataDef = new MultiNoteEndDefinition();
//    else if (abcTokenType==(AbcTokenType.TEX_COMMAND)) automataDef = new TexCommandDefinition();
    else if (abcTokenType==(AbcTokenType.CHORD_NAME)) automataDef = new ChordNameDefinition();
    else if (abcTokenType==(AbcTokenType.EQUALS)) automataDef = new EqualsDefinition();
    else if (abcTokenType==(AbcTokenType.C_TEMPO)) automataDef = new TempoCDefinition();
    else if (abcTokenType==(AbcTokenType.COMA)) automataDef = new ComaDefinition();
    else throw new RuntimeException("NO AUTOMATA FOR " + abcTokenType);
    cacheDef = new DefinitionCache(tokenTypes, automataDef);
    m_allPreviouslyCreatedDefinitions.add(cacheDef);
    //System.out.println("Creating item in cache for  " + toString(tokenTypes));

    }
//    else
//      System.out.println("Using cache for  " + toString(tokenTypes));

    return cacheDef;
  }

  public static DefinitionCache getDefinition(TokenType[] tokenTypes)
  {
//    System.out.println("getAutomataFor(" + toString(tokenTypes));
    DefinitionCache alreadyCreated = getCacheDefinition(tokenTypes);
    if (alreadyCreated!=null)
    {
//      System.out.println("Cache used for " + toString(tokenTypes));
      return alreadyCreated;
    }
    else
    {
      DefinitionCache cache = getDefinition(tokenTypes[0]);
      AutomataDefinition definition = cache.getAutomata();
      for (int i=1;i<tokenTypes.length; i++)
        definition = definition.union(getDefinition(tokenTypes[i]).getAutomata());
      //System.out.println("Adding automataDef in cache for : " + toString(tokenTypes));
      cache = new DefinitionCache(tokenTypes, definition);
      m_allPreviouslyCreatedDefinitions.addElement(cache);
      return cache;
    }
  }

  private static DefinitionCache getCacheDefinition(TokenType[] tokenTypes)
  {
    DefinitionCache alreadyCreatedDefinition = null;
    for (int i=0; i<m_allPreviouslyCreatedDefinitions.size() && (alreadyCreatedDefinition== null); i++)
    {
      if (((DefinitionCache)m_allPreviouslyCreatedDefinitions.elementAt(i)).isValidFor(tokenTypes))
        alreadyCreatedDefinition = (DefinitionCache)m_allPreviouslyCreatedDefinitions.elementAt(i);
    }
    return alreadyCreatedDefinition;
  }

  public static class DefinitionCache
  {
    private TokenType[] m_tokenTypes=null;
    private AutomataDefinition m_automataDefResult=null;

    public DefinitionCache(TokenType[] tokenTypes, AutomataDefinition automataDef)
    {
      m_tokenTypes = tokenTypes;
      m_automataDefResult = automataDef;
    }

    public boolean isValidFor(TokenType[] tokenTypes)
    {
      boolean isValidFor = true;
      if (m_tokenTypes.length==tokenTypes.length)
      {
        for (int i=0; i<m_tokenTypes.length && isValidFor; i++)
          if (!contains(m_tokenTypes[i], tokenTypes))
            isValidFor=false;
      }
      else
        isValidFor = false;
      return isValidFor;
    }

    public AutomataDefinition getAutomata()
    { return m_automataDefResult; }

    public TokenType[] getTokenTypes()
    { return m_tokenTypes; }

  }

  private static boolean contains(TokenType type, TokenType[] types)
  {
    boolean contains = false;
    int index = 0;
    while (!contains && index<types.length)
      if (type.equals(types[index]))
        contains = true;
      else
        index++;
    return contains;
  }

  public static String toString(TokenType[] types)
  {
    String s = "[";
    for (int i=0; i<types.length; i++)
      s = s.concat("," + types[i].toString());
    s = s.concat("]");
    return s;

  }
}